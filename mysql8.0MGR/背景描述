2	组复制背景Group Replication Background


创建容错系统最常见的方法是诉诸于使组件冗余，换句话说，组件可以被删除，系统应继续按预期运行。这造成了一系列挑战，将此类系统的复杂性提高到了一个完全不同的水平。具体来说，复制的数据库必须处理这样一个事实，即它们需要维护和管理多个服务器，而不仅仅是一个服务器。此外，随着服务器合作创建该组，必须处理其他几个经典的分布式系统问题，如网络分区或脑裂场景。

因此，最终的挑战是将数据库和数据复制的逻辑与以一致和简单的方式协调多个服务器的逻辑融合在一起。换句话说，让多个服务器就系统的状态和系统经历的每一个更改的数据达成一致。这可以总结为让服务器就每个数据库状态转换达成一致，以便它们都作为一个数据库进行，或者最终收敛到相同的状态。这意味着它们需要作为（分布式）状态机运行。

MySQL组复制提供了分布式状态机复制，服务器之间具有很强的协调性。当服务器属于同一组时，它们会自动协调自己。该组可以在具有自动主选举的单主模式下运行，其中一次只有一台服务器接受更新。或者，对于更高级的用户，该组可以部署在多主模式下，在这种模式下，所有服务器都可以接受更新，即使更新是同时发布的。这种能力是以牺牲应用程序必须克服此类部署所施加的限制为代价的。

有一个内置的组成员身份服务，它可以保持组的视图一致，并在任何给定时间点对所有服务器都可用。服务器可以离开并加入组，视图也会相应更新。有时服务器可能会意外离开组，在这种情况下，故障检测机制会检测到这一点，并通知组视图已更改。这都是自动的。

要提交事务，组的大多数成员必须就全局事务序列中给定事务的顺序达成一致。决定提交或中止事务是由每个服务器单独完成的，但所有服务器都会做出相同的决定。如果存在网络分区，导致成员无法达成一致的分裂，则在此问题得到解决之前，系统不会进展。因此，还有一个内置的、自动的、脑裂保护机制。

所有这些都由提供的组通信系统（GCS）协议提供支持。这些功能提供了故障检测机制、组成员身份服务以及安全且完全有序的消息传递。所有这些属性都是创建系统的关键，该系统确保数据在服务器组之间一致复制。这项技术的核心是Paxos算法的实现。它充当组通信引擎。

Replication Technologies
在深入了解MySQL组复制的详细信息之前，本节介绍了一些背景概念和工作原理的概述。这提供了一些上下文，以帮助了解组复制所需的内容，以及经典异步MySQL复制和组复制之间的区别。

Source to Replica Replication
传统的MySQL复制提供了一种简单的源到副本的复制方法。源是主副本，有一个或多个副本，它们是辅助副本。源应用事务，提交事务，然后（因此异步）将它们发送到复制副本，以便重新执行（在基于语句的复制中）或应用（在基于行的复制中）。它是一个无共享系统，默认情况下，所有服务器都有数据的完整副本。

 

还有半同步复制，它在协议中添加了一个同步步骤。这意味着主服务器在应用时等待辅助服务器确认它已收到事务。只有这样，主服务器才会恢复提交操作。
 
在这两张图片中，有一个经典的异步MySQL复制协议（以及它的半同步变体）的图表。对角线箭头表示服务器之间交换的消息或服务器与客户端应用程序之间交换的消息。


Group Replication
组复制是一种可用于实现容错系统的技术。复制组是一组服务器，每个服务器都有自己的数据的整个副本（无共享复制方案），并通过消息传递相互交互。通信层提供了一套保证，如原子消息和总订单消息传递。这些都是非常强大的属性，可以转化为非常有用的抽象，人们可以利用这些抽象来构建更高级的数据库复制解决方案。

MySQL组复制构建在这些属性和抽象的基础上，并实现了多源更新无处不在的复制协议。复制组由多个服务器组成，组中的每个服务器可以随时独立执行事务。但是，所有读写事务只有在组批准后才会提交。换句话说，对于任何读写事务，组都需要决定它是否提交，因此提交操作不是单方面的决定来自源服务器。只读事务不需要在组内进行协调，并立即提交。

当读写事务准备在源服务器上提交时，服务器将原子广播写入值（已更改的行）和相应的写入集（已更新行的唯一标识符）。由于事务是通过原子广播发送的，因此组中的所有服务器要么都接收事务，要么都不接收事务。如果他们收到了它，那么他们都以相同的顺序接收它，与之前发送的其他事务有关。因此，所有服务器都以相同的顺序接收相同的事务集，并为事务建立全局总顺序。

但是，在不同服务器上并发执行的事务之间可能存在冲突。在一个称为认证的过程中，通过检查和比较两个不同的并发事务的写入集来检测此类冲突。在认证期间，冲突检测在行级执行：如果在不同服务器上执行的两个并发事务更新同一行，则存在冲突。冲突解决过程指出，首先订购的事务提交所有服务器，事务订购了第二次中止，因此在源服务器上回滚，并由组中的其他服务器删除。例如，如果t1和t2在不同的站点并发执行，两者都更改了同一行，并且t2在t1之前排序，则t2赢得冲突，t1将回滚。这实际上是一个分布式的第一次提交赢规则。请注意，如果两个事务经常发生冲突，则在同一服务器上启动它们是一个良好的做法，在同一服务器上，它们有机会在本地锁管理器上同步，而不是由于认证而回滚。

对于应用和外部化经认证的事务，组复制允许服务器偏离商定的事务顺序，如果这不破坏一致性和有效性。组复制是一个最终的一致性系统，这意味着一旦传入流量减慢或停止，所有组成员都具有相同的数据内容。当流量流动时，事务可以以稍微不同的顺序外部化，也可以在某些成员上外部化，然后在其他成员上外部化。例如，在多主模式下，本地事务可能会在认证后立即外部化，尽管尚未应用全局顺序中较早的远程事务。当认证过程确定交易之间没有冲突时，允许这样做。在单主模式下，在主服务器上，并发、不冲突的本地事务可能会以与组复制商定的全局顺序不同的顺序提交和外部化。在不接受客户端写入的辅助设备上，事务始终按商定的顺序提交和外部化。

下图描述了MySQL组复制协议，通过将其与MySQL复制（甚至MySQL半同步复制）进行比较，您可以看到一些差异。为了清楚起见，这张图片中缺少了一些基本的共识和Paxos相关的信息。
 

3	多主和单组模式Multi-Primary and Single-Primary Modes

组复制在单主模式或多主模式下运行。组的模式是组范围的配置设置，由group_replication_single_primary_mode系统变量指定，该变量在所有成员上必须相同。ON表示单主模式，这是默认模式，OFF表示多主模式。不可能将组成员部署在不同的模式下，例如，一个成员配置在多主模式下，而另一个成员配置在单主模式下。

组复制正在运行时，您不能手动更改group_replication_single_primary_mode的值。从MySQL 8.0.13开始，您可以使用group_replication_switch_to_single_primary_mode()和group_replication_switch_to_multi_primary_mode()UDF将组从一种模式移动到另一种模式，而组复制仍在运行。这些UDF管理更改组模式的过程，并确保数据的安全性和一致性。在早期版本中，要更改组的模式，必须停止组复制并更改所有成员上的group_replication_single_primary_mode的值。然后执行组的完全重新启动（由group_replication_bootstrap_group=ON的服务器引导），以实施对新操作配置的更改。不需要重新启动服务器。

无论部署模式如何，组复制都不处理客户端故障切换。这必须由中间件框架（如MySQL Router 8.0）、proxy、connector或应用程序本身来处理

Single-Primary Mode 
在单主模式下（group_replication_Single_Prime_mode=ON），组有一个设置为读写模式的主服务器。组中的所有其他成员都设置为只读模式(super_read_only=ON)。主服务器通常是引导组的第一个服务器。加入组的所有其他服务器都会了解主服务器，并自动设置为只读模式。

在单主模式下，组复制强制只有单个服务器写入组，因此与多主模式相比，一致性检查可能不那么严格，DDL语句不需要额外小心处理。选项group_replication_enforce_update_everywhere_checks启用或禁用组的严格一致性检查。在单主模式下部署或将组更改为单主模式时，此系统变量必须设置为OFF。

指定为主服务器的成员可以通过以下方式更改：
	如果现有的初选离开组，无论是自愿的还是意外的，新的初选都会自动选出。
	您可以使用group_replication_set_as_primary()UDF。
	如果您使用group_replication_switch_to_single_primary_mode()UDF将在多主模式下运行的组更改为在单主模式下运行，则会自动选举新的主，或者，您可以通过使用UDF指定新的主服务器来指定它。

只有当所有组成员都运行MySQL 8.0.13或更高版本时，才能使用UDF。当自动选举或手动指定新的主服务器时，它将自动设置为读写，其他组成员将保持为辅助服务器，因此，read-only。图18.4“新初选”显示了此过程
 
当选择或指定新的主服务器时，它可能会有已应用于旧主服务器但尚未应用于此服务器的更改积压。在这种情况下，在新的主服务器赶上旧的主服务器之前，读写事务可能会导致冲突并回滚，只读事务可能会导致过时的读取。组复制的流量控制机制将快速成员和慢成员之间的差异降至最低，如果激活并正确调整，则会降低发生这种情况的可能性。从MySQL 8.0.14开始，您还可以使用group_replication_consistency系统变量来配置组的事务一致性级别，以防止此问题。设置在应用积压BEFORE_ON_PRIMARY_FAILOVER（或任何更高的一致性级别）将新事务保留在新当选的主事务上。有关事务一致性的更多信息，请参见第18.4.2节“事务一致性保证”。如果未对组使用流控制和事务一致性保证，则在将客户端应用程序重新路由到该组之前，最好等待新主应用程序应用其复制相关中继日志。

Primary Election Algorithm初选算法
自动主要成员选举过程包括每个成员查看组的新视图，对潜在的新主要成员进行排序，并选择符合最合适的成员。每个成员都会按照MySQL Server版本中的主要选举算法在本地做出自己的决定。由于所有成员都必须达成相同的决定，因此如果其他组成员运行的MySQL Server版本较低，成员会调整其主要选举算法，以便他们与组中MySQL Server版本最低的成员具有相同的行为。

成员在选举初选时考虑的因素依次如下：
1.考虑的第一个因素是哪个或多个成员运行的是最低的MySQL Server版本。如果所有组成员都运行MySQL 8.0.17或更高版本，则成员首先按其版本的补丁版本排序。如果任何成员运行的是MySQL Server 5.7或MySQL 8.0.16或更低版本，则成员首先按其版本的主要版本排序，而修补程序版本将被忽略。
2.如果多个成员运行的是最低的MySQL Server版本，则考虑的第二个因素是这些成员中每个成员的成员权重，由成员上的group_replication_member_weight系统变量指定。如果组的任何成员正在运行MySQL Server 5.7，而此系统变量不可用，则将忽略此因素。
group_replication_member_weight系统变量指定范围为0-100的数字。所有成员默认权重为50，因此将权重设置为低于此值以降低其顺序，将权重设置为高于此值以增加其顺序。您可以使用此加权函数来优先使用更好的硬件，或确保在主设备的计划维护期间故障切换到特定成员。
3.如果多个成员运行的是最低的MySQL Server版本，并且其中多个成员具有最高的成员权重（或成员权重被忽略），则考虑的第三个因素是每个成员生成的服务器UUID的词典顺序，由server_uuid系统变量指定。服务器UUID最低的成员被选择为主要成员。此因素充当有保证和可预测的决胜局，以便所有组成员在无法由任何重要因素确定时达成相同的决定。

Finding the Primary查找主节点
要确定在单主模式下部署时，哪个服务器当前是主服务器，请使用performance_schema.replication_group_members表中的MEMBER_ROLE列。示例：
mysql> SELECT MEMBER_HOST, MEMBER_ROLE FROM performance_schema.replication_group_members;
+-------------------------+-------------+
| MEMBER_HOST | MEMBER_ROLE |
+-------------------------+-------------+
| remote1.example.com | PRIMARY |
| remote2.example.com | SECONDARY |
| remote3.example.com | SECONDARY |
+-------------------------+-------------+
Warning
The group_replication_primary_member status variable has been
deprecated and is scheduled to be removed in a future version.

Multi-Primary Mode
在多主模式下（group_replication_Single_Prime_mode=OFF），没有成员具有特殊角色。与其他组成员兼容的任何成员在加入组时都将设置为读写模式，并且可以处理写入事务，即使这些事务是并发发出的。
如果成员停止接受写事务，例如，在服务器意外退出的情况下，连接到它的客户端可以重定向或故障转移到处于读写模式的任何其他成员。组复制本身不处理客户端故障切换，因此您需要使用中间件框架（如MySQL Router 8.0）、代理、连接器或应用程序本身来安排此故障切换。
图18.5“客户端故障转移”显示了如果成员离开组，客户端如何重新连接到备用组成员。
 
组复制是最终的一致性系统。这意味着，一旦传入流量变慢或停止，所有组成员都具有相同的数据内容。当流量流动时，事务可以在某些成员上外部化，而不是其他成员，特别是如果某些成员的写入吞吐量低于其他成员，则会产生过时读取的可能性。在多主模式下，速度较慢的成员还可能积累过多的事务积压来认证和应用，导致冲突和认证失败的风险更大。要限制这些问题，您可以激活和调整组复制的流量控制机制，以最大限度地减少快速成员和慢成员之间的差异。有关流的更多信息控制，请参见第18.7.2节“流量控制”。

从MySQL 8.0.14开始，如果您希望为组中的每个事务都有事务一致性保证，您可以使用group_replication_consistency系统变量来执行此操作。您可以选择适合组的工作负载和数据读取和写入优先级的设置，同时考虑到提高一致性所需的同步对性能的影响。您还可以为单个会话设置系统变量，以保护特别敏感的并发事务。有关事务一致性的更多信息，请参见第18.5.2节“事务一致性保证”。

Transaction Checks
当组部署在多主模式下时，会检查事务以确保它们与模式兼容。在多主模式下部署组复制时，会进行以下严格的一致性检查：
1.	如果事务是在串行化隔离级别下执行的，则在与组同步时，其提交将失败。
2.	如果事务对具有级联约束的外键的表执行，则在与组同步时，其提交将失败。

检查由group_replication_enforce_update_everywhere_checks系统变量。在多主模式下，系统变量通常应设置为ON，但可以选择通过将系统变量设置为OFF来停用检查。在单主模式下部署时，系统变量必须设置为OFF。

Data Definition Statements
在多主模式下的组复制拓扑中，执行数据定义语句（也通常称为数据定义语言(DDL）)时需要小心。
MySQL 8.0引入了对原子数据定义语言（DDL）语句的支持，其中完整的DDL语句作为单个原子事务提交或回滚。但是，DDL语句（原子语句或其他语句）隐式结束当前会话中处于活动状态的任何事务，就像您在执行语句之前执行了提交一样。这意味着DDL语句不能在另一个事务中执行，在事务控制语句中执行，如START事务...提交，或与同一事务中的其他语句组合。
组复制基于乐观复制范式，在这种范式中，语句将乐观执行，并在必要时稍后回滚。每个服务器在不首先保护组协议的情况下执行。因此，在多主模式下复制DDL语句时需要更加小心。如果您对同一对象进行架构更改（使用DDL）和对象包含的数据更改（使用DML），则需要通过同一服务器处理更改，而架构操作尚未完成并在任何地方复制。如果不这样做，可能会导致操作中断或仅部分完成时数据不一致。如果组部署在单主模式下，则不会发生此问题，因为所有更改都是通过同一服务器（即主服务器）执行的。

For details on atomic DDL support in MySQL 8.0, and the resulting changes in behavior for the replication
of certain statements, see Section 13.1.1, “Atomic Data Definition Statement Support”.

Version Compatibility版本兼容性
为了获得最佳兼容性和性能，组的所有成员都应运行相同版本的MySQL Server，因此也应运行相同版本的组复制。在多主模式下，这一点更重要，因为所有成员通常都会在读写模式下加入组。如果一个组包括运行多个MySQL Server版本的成员，则某些成员可能与其他成员不兼容，因为它们支持其他成员不支持的功能，或者缺乏其他成员拥有的功能。为了防止这种情况，当新成员加入（包括已升级和重新启动的前成员）时，该成员对组的其他成员执行兼容性检查。

这些兼容性检查的一个结果在多主模式中尤为重要。如果加入成员运行的MySQL Server版本高于现有组成员运行的最低版本，则它将加入组，但仍处于只读模式。（在以单主模式运行的组中，新添加的成员在任何情况下都默认为只读。）运行MySQL 8.0.17或更高版本的成员在检查其兼容性时考虑版本的补丁版本。运行MySQL 8.0.16或更低版本或MySQL 5.7的成员仅考虑主版本。

在以多主模式运行的组中，成员使用不同MySQL Server版本，组复制自动管理运行MySQL 8.0.17或更高版本的成员的读写和只读状态。如果成员离开组，则运行现在最低版本的成员将自动设置为读写模式。当您将在单主模式下运行的组更改为在多主模式下运行时，使用group_replication_switch_to_multi_primary_mode()函数，组复制会自动将成员设置为正确的模式。如果成员运行的MySQL服务器版本高于组中存在的最低版本，则他们将自动置于只读模式，并且运行最低版本的成员将置于读写模式。

4	组复制服务Group Replication Services
Group Membership
在MySQL组复制中，一组服务器组成一个复制组。组有一个名称，它采用UUID的形式。该组是动态的，服务器可以离开（自愿或非自愿）并随时加入它。每当服务器加入或离开时，组就会自行调整。
如果服务器加入组，它将通过从现有服务器获取缺少的状态来自动使自己更新。如果服务器离开组，例如它被删除以进行维护，其余服务器会注意到它已经离开，并自动重新配置组。

组复制具有组成员身份服务，该服务定义哪些服务器处于联机状态并参与组。联机服务器列表称为视图。组中的每个服务器都有一个一致的视图，说明哪些服务器是在给定时间积极参与组的成员。

组成员不仅必须就事务提交达成一致，而且还必须就当前视图达成一致。如果现有成员同意新服务器应成为组的一部分，则会重新配置组以将该服务器集成到其中，这将触发视图更改。如果服务器自愿或不自愿离开组，组将动态重新排列其配置，并触发视图更改。

如果成员自愿离开组，它首先启动动态组重新配置，在此期间，所有成员必须在没有离开服务器的情况下就新视图达成一致。但是，如果成员非自愿离开组，例如因为它意外停止或网络连接断开，它将无法启动重新配置。在这种情况下，组复制的故障检测机制在短时间内识别成员已离开，并建议重新配置没有故障成员的组。与自愿离开的成员一样，重新配置需要得到组中大多数服务器的同意。但是，如果组无法达成一致，例如，因为它分区的方式是没有大多数服务器在线，系统无法动态更改配置，和阻止以防止脑裂的情况。这种情况需要管理员的干预。

成员可以在短时间内脱机，然后在故障检测机制检测到其故障之前，以及在重新配置组以删除成员之前，尝试重新加入组。在这种情况下，重新加入成员会忘记其以前的状态，但如果其他成员向其发送旨在用于其崩溃前状态的消息，这可能会导致包括可能数据不一致在内的问题。如果在这种情况下的成员参加了XCom的共识协议，它可能会导致XCom在失败前后做出不同的决定，为同一共识一轮提供不同的价值。

为了应对这种可能性，从MySQL 5.7.22和MySQL 8.0中，组复制检查同一服务器的新化身试图加入组，而其旧化身（具有相同地址和端口号）仍被列为成员的情况。新化身被阻止加入组，直到旧化身可以通过重新配置删除。请注意，如果group_replication_成员_expel_timeout系统变量添加了等待期，以允许成员在被驱逐之前重新连接到组的额外时间，如果被怀疑的成员在怀疑超时之前重新连接到该组，则可以作为其当前化身再次活跃在该组中。当成员超过驱逐超时并从组中驱逐时，或者当组复制在服务器上被STOP GROUP_REP语句停止或服务器故障时，它必须作为新的化身重新加入。


Failure Detection
组复制包括一个故障检测机制，该机制能够查找和报告哪些服务器处于静默状态，因此假定哪些服务器处于死机状态。在高层次上，故障检测器是一个分布式服务，它提供有关哪些服务器可能已死（怀疑）的信息。当服务器静音时，会触发怀疑。当服务器A在给定的时间内没有收到来自服务器B的消息时，会发生超时并引起怀疑。稍后，如果组同意怀疑可能是真的，则组决定给定的服务器确实发生了故障。这意味着集团中的其余成员作出协调决定，驱逐特定成员。

如果服务器与组的其他成员隔离，则它怀疑所有其他服务器都发生了故障。由于无法与该集团达成协议（因为它无法确保法定人数），其怀疑不会产生后果。当服务器以这种方式与组隔离时，它无法执行任何本地事务。

如果网络不稳定，成员经常以不同的组合失去和恢复彼此的联系，理论上，一个团体最终有可能将其所有成员标记为驱逐，之后该团体将不复存在，必须再次成立。为了应对这种可能性，从MySQL 8.0.20开始，组复制的组通信系统（GCS）跟踪已标记为驱逐的组成员，并在决定是否有多数时将他们视为可疑成员组中。这可确保组中至少有一个成员保留，并且组可以继续存在。当被驱逐的成员实际被从组中删除时，GCS将删除其标记为驱逐成员的记录，以便该成员在能够的情况下可以重新加入组。

Fault-tolerance容错
MySQL组复制构建在Paxos分布式算法的实现之上，以提供服务器之间的分布式协调。因此，它要求大多数服务器处于活动状态才能达到法定人数，从而做出决定。这直接影响系统可以容忍的故障数量，而不损害自身及其整体功能。容忍f个故障所需的服务器数量(n)为n = 2 x f + 1。

在实践中，这意味着要容忍一次故障，组必须有三台服务器。因此，如果一台服务器发生故障，仍有两台服务器构成多数（三分之二），并允许系统继续自动做出决策并进行。但是，如果第二台服务器非自愿故障，则组（还剩一台服务器）将阻塞，因为没有多数可以做出决定。

下面是一个小表，说明了上面的公式。
 

Observability可观察性
组复制插件中内置了许多自动化功能。尽管如此，你有时可能需要了解幕后发生了什么。这就是组复制和性能架构的检测变得重要的地方。系统的整个状态（包括视图、冲突统计信息和服务状态）可以通过性能架构表查询。
复制协议的分布式性质以及服务器实例同意并因此同步事务和元数据的事实，使检查组状态变得更简单。例如，您可以连接到组中的单个服务器，并通过在与组复制相关的性能架构表上发出select语句来获取本地和全局信息。


5	组复制插件架构Group Replication Plugin Architecture
MySQL组复制是一个MySQL插件，它构建在现有的MySQL复制基础架构之上，利用二进制日志、基于行的日志记录和全局事务标识符等功能。它与当前的MySQL框架集成，例如性能模式或插件和服务基础架构。下图显示了一个框图，描述了MySQL组复制的整体体系结构。
 

MySQL组复制插件包括一组用于捕获、应用和生命周期的API，这些API控制插件如何与MySQL Server交互。有一些接口可以使信息从服务器流动到插件，反之亦然。这些接口将MySQL Server核心与组复制插件隔离开来，并且主要是放置在事务执行管道中的钩子。在一个方向上，从服务器到插件，都有事件的通知，如服务器启动、服务器恢复、服务器准备接受连接以及服务器即将提交事务。在另一个方向上，插件指示服务器执行操作，如提交或中止正在进行的事务，或在中继日志中排队事务。

组复制插件体系结构的下一层是一组组件，当通知路由到它们时，它们会做出反应。捕获组件负责跟踪与正在执行的事务相关的上下文。应用程序组件负责在数据库上执行远程事务。恢复组件管理分布式恢复，并负责通过选择捐赠者、管理追赶过程和对捐赠者故障做出反应，使加入组的服务器保持最新。

继续向下堆栈，复制协议模块包含复制协议的特定逻辑。它处理冲突检测，并接收事务并将其传播到组。

组复制插件体系结构的最后两层是组通信系统(GCS)API和基于Paxos的组通信引擎（XCom）的实现。GCS API是一个高级API，它抽象了构建复制状态机所需的属性（请参见第18.1节“组复制背景”）。因此，它将消息层的实现与插件的其余上层解耦。组通信引擎处理与复制组成员的通信。
